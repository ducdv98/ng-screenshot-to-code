# Technical Guide: Full Angular Project Generation

## 1. Introduction & Goal

This document outlines a revised technical approach for the "Screenshot/Figma to Angular Code Generator" project. Recognizing the difficulties associated with live previews (Technical Challenge #7) and ensuring correct configuration context (Technical Challenge #9), the project will pivot from generating code snippets to generating a **complete, minimal, runnable Angular project** as a downloadable archive (e.g., ZIP file).

**Primary Goal:** Provide users with a functional Angular (v19+) application, pre-configured with Angular Material (v17+) and Tailwind CSS (v3), containing the UI generated by the VLM based on the input image or Figma design. The output should be ready for local execution (`npm install && ng serve`) with minimal or no modification.

**Deprecation:** The live preview feature (Requirement F6) and associated UI elements (code viewers, preview pane) will be deprioritized and likely removed in favor of the downloadable project output.

## 2. Core Architectural Change

The fundamental change involves shifting the backend's responsibility from producing isolated code strings (TS, HTML, SCSS) to assembling an entire Angular CLI project structure in memory, populating it with both standard boilerplate and AI-generated code, and then packaging it for download.

* **Input:** Remains the same (Image or Figma URL via frontend).
* **Processing:** VLM analyzes input and generates code/structure information.
* **Backend Assembly:** A backend service orchestrates the creation of a complete file/directory structure based on VLM output and predefined templates.
* **Output:** A downloadable `.zip` archive containing the full frontend project.

## 3. Backend Implementation Details

### 3.1. Prompt Engineering Overhaul

The prompt sent to the VLM (e.g., Gemini Flash) needs a major redesign to support generating the necessary information for a full project.

* **Hybrid Approach (Recommended):** This is likely the most balanced approach regarding prompt complexity, AI reliability, and output consistency.
    * **AI Focus:** Instruct the AI to focus on generating the core *application-specific* code:
        * The main `AppComponent` (TS, HTML, SCSS) that structures the page and hosts other generated components.
        * Any identified child components (TS, HTML, SCSS), leveraging the conditional component splitting logic previously defined.
        * Potentially basic routing setup if multiple generated "pages" or views are identified.
    * **Output Format:** Request the output as a structured JSON object containing the `components` array (as defined in previous guides), potentially adding a property for suggested basic routes.
        ```json
        {
          "components": [
            { "componentName": "...", "typescript": "...", "html": "...", "scss": "..." },
            // ... more components
          ],
          "routing": [ // Optional: Basic routing suggestions
            // { "path": "", "componentName": "MainPageComponent" }
          ]
        }
        ```
    * **AI Instructions:** The prompt must still include all the advanced elements previously discussed (Role, Goal adjusted for project generation support, Tech Stack Constraints for Angular v19+/Material v17+/Tailwind, Config Assumptions, Few-Shot Examples showing component generation, Reasoning Steps).
* **Alternative (Full Generation - Higher Risk):** Prompting the AI to generate *all* files (including `package.json`, `angular.json`, etc.). This is highly complex for the AI, prone to errors/inconsistencies, and likely exceeds context limits for complex projects. *Not Recommended.*

### 3.2. Project Assembly Service

* **Location:** A new or expanded backend service (e.g., `project_assembler_service.py` potentially called by `code_generator.py`).
* **Responsibilities:**
    1.  **Receive AI Output:** Take the parsed JSON data (containing generated components/routes) from the VLM response.
    2.  **Load Boilerplate:** Access predefined templates for standard Angular CLI project files (See Section 5: Target Project Structure).
    3.  **Create Virtual File System:** Construct an in-memory representation of the target project directory structure.
    4.  **Populate Boilerplate:** Copy the standard configuration files (`package.json`, `angular.json`, `tailwind.config.js`, `tsconfig.json`, `src/main.ts`, `src/styles.scss`, `src/app/app.config.ts`, etc.) into the virtual file system. Ensure placeholders in templates (e.g., project name in `package.json`/`angular.json`) are filled.
    5.  **Integrate AI Code:**
        * Place the generated component files (TS, HTML, SCSS) into appropriate subdirectories within `src/app/` (e.g., `src/app/[component-name]/`).
        * Modify the root `AppComponent` template (`src/app/app.component.html`) to use the primary generated component's selector (e.g., `<app-main-page>`).
        * Modify `app.routes.ts` based on AI suggestions or default to routing to the primary component.
        * Ensure necessary imports are added to relevant modules/standalone components (e.g., importing generated child components into parent components, basic routing config).
    6.  **Return File Structure:** Output the complete virtual file structure (e.g., as a dictionary mapping file paths to string content).

### 3.3. Packaging Service

* **Location:** A backend utility or service (e.g., `packaging_service.py`).
* **Responsibilities:**
    1.  **Receive File Structure:** Take the virtual file system representation from the Assembly Service.
    2.  **Create ZIP Archive:** Generate a `.zip` archive containing all the files and directories according to the structure. Use standard Python libraries (like `zipfile`) for this.
    3.  **Return Archive:** Provide the generated ZIP archive as an in-memory object or stream.

### 3.4. API Endpoint Modification

* **Location:** `backend/app/api/v1/endpoints/generate_code.py` (or equivalent).
* **Changes:**
    1.  The endpoint still receives the input (Image/Figma data, potentially selected model/API key).
    2.  It orchestrates the call to the VLM, the Project Assembly Service, and the Packaging Service.
    3.  **Return Type:** Change the return type to serve a file download. Use appropriate HTTP headers:
        * `Content-Type: application/zip`
        * `Content-Disposition: attachment; filename="generated_angular_project.zip"`
    4.  Stream the generated ZIP archive content back in the response body.

### 3.5. Multi-Model Support

* The multi-model selection and user API key logic (from previous guides) remains relevant for the **VLM interaction step** within the backend. The user can still choose which model generates the component code that is then assembled into the project structure.

## 4. Frontend Implementation Details

### 4.1. UI Changes

* **Location:** `frontend/src/app/pages/generator-page/`
* **Modifications:**
    * Remove the `CodeViewerComponent` instances and the `PreviewPaneComponent` (or their container elements).
    * Keep the input elements (Image uploader, Figma input).
    * Keep the Multi-Model selection UI (if implemented).
    * Replace the primary action button's text/functionality or add a new prominent button: "Generate & Download Project (.zip)".
    * Maintain loading indicators and error message displays.

### 4.2. API Interaction & Download Handling

* **Location:** `frontend/src/app/services/api.service.ts`, `frontend/src/app/pages/generator-page/generator-page.component.ts`
* **Changes:**
    1.  Modify the `ApiService` method (`generateCodeFromImage` or equivalent) to expect a file blob/stream as the response type instead of JSON containing code strings. Set appropriate `Accept` headers if needed and ensure the response type is handled correctly (e.g., `responseType: 'blob'` in Angular `HttpClient`).
    2.  In the `GeneratorPageComponent` component:
        * Call the updated `ApiService` method.
        * Upon receiving a successful response (the file blob):
            * Use browser APIs (e.g., creating an object URL `URL.createObjectURL(blob)` and simulating a link click) to trigger the file download for the user, naming the file `generated_angular_project.zip`.
            * Handle potential errors during the API call or download process.

## 5. Target Project Structure Output (Minimal Example)

The generated ZIP file should unpack to a structure like this:
generated_angular_project/
├── angular.json
├── package.json
├── package-lock.json (Optional, usually generated by npm install)
├── postcss.config.js
├── tailwind.config.js
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.spec.json
├── .gitignore
└── src/
├── main.ts
├── index.html
├── styles.scss               # Includes Material Theme & Tailwind imports
└── app/
├── app.config.ts         # Provides provideAnimationsAsync etc.
├── app.routes.ts         # Basic routing
├── app.component.html    # Root component template (uses generated component selector)
├── app.component.scss
├── app.component.ts      # Root component TS
└── [component-name]/     # Folder for the primary AI-generated component
├── [component-name].component.html
├── [component-name].component.scss
├── [component-name].component.ts
└── [child-component-name]/ # Optional: Folder for AI-generated child component
├── [child-component-name].component.html
├── [child-component-name].component.scss
├── [child-component-name].component.ts
# ... potentially more generated components

## 6. Benefits & Tradeoffs

* **Benefits:**
    * Highly practical output, directly runnable by the user.
    * Eliminates configuration mismatches between generated code and user's environment.
    * Completely avoids the complexities and limitations of the live preview feature.
    * Provides a solid starting point for further development.
* **Tradeoffs:**
    * Increased backend complexity (project assembly, packaging).
    * Potentially larger data generation/transfer compared to snippets.
    * AI generation challenge shifts from just component code to ensuring components integrate correctly within the standard boilerplate (handled partly by assembly logic).
    * Loss of immediate visual feedback (preview).

This approach significantly increases the practical value of the tool by delivering a complete, working project artifact.

Sources and related content
